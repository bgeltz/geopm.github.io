<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>geopm: geopm::Agent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">geopm
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegeopm.html">geopm</a></li><li class="navelem"><a class="el" href="classgeopm_1_1_agent.html">Agent</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classgeopm_1_1_agent-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">geopm::Agent Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_agent_8hpp_source.html">Agent.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a63f44ae327dda74fa4b9642c580aece2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a63f44ae327dda74fa4b9642c580aece2">Agent</a> ()=default</td></tr>
<tr class="separator:a63f44ae327dda74fa4b9642c580aece2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25bcbffb10acf177ac9294f24a6e211"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ae25bcbffb10acf177ac9294f24a6e211">~Agent</a> ()=default</td></tr>
<tr class="separator:ae25bcbffb10acf177ac9294f24a6e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c94fff3ed8f580526e51aeb25cf4758"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a2c94fff3ed8f580526e51aeb25cf4758">init</a> (int level, const std::vector&lt; int &gt; &amp;fan_in, bool is_level_root)=0</td></tr>
<tr class="memdesc:a2c94fff3ed8f580526e51aeb25cf4758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the level where this <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is active and push signals/controls for that level.  <a href="#a2c94fff3ed8f580526e51aeb25cf4758">More...</a><br /></td></tr>
<tr class="separator:a2c94fff3ed8f580526e51aeb25cf4758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f4eb74c2f1c50b9c85fc988de8c4c0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a76f4eb74c2f1c50b9c85fc988de8c4c0">validate_policy</a> (std::vector&lt; double &gt; &amp;policy) const =0</td></tr>
<tr class="memdesc:a76f4eb74c2f1c50b9c85fc988de8c4c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by Controller to validate incoming policy values and configure defaults requested in incoming policy. Policy sender can request default value with 'NaN' at the desired offset in the policy vector. Returned policy should not contain 'NaN's and be consumeable by descend and adjust_platform.  <a href="#a76f4eb74c2f1c50b9c85fc988de8c4c0">More...</a><br /></td></tr>
<tr class="separator:a76f4eb74c2f1c50b9c85fc988de8c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33501debc601b7a69bee243c9a3a2351"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a33501debc601b7a69bee243c9a3a2351">split_policy</a> (const std::vector&lt; double &gt; &amp;in_policy, std::vector&lt; std::vector&lt; double &gt; &gt; &amp;out_policy)=0</td></tr>
<tr class="memdesc:a33501debc601b7a69bee243c9a3a2351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by Controller to split policy for children at next level down the tree.  <a href="#a33501debc601b7a69bee243c9a3a2351">More...</a><br /></td></tr>
<tr class="separator:a33501debc601b7a69bee243c9a3a2351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa31a7c9beb554f2e992b8ba3f550edd0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#aa31a7c9beb554f2e992b8ba3f550edd0">do_send_policy</a> (void) const =0</td></tr>
<tr class="memdesc:aa31a7c9beb554f2e992b8ba3f550edd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by Controller to determine if new policy values should be sent down the tree to the <a class="el" href="classgeopm_1_1_agent.html">Agent</a>'s children.  <a href="#aa31a7c9beb554f2e992b8ba3f550edd0">More...</a><br /></td></tr>
<tr class="separator:aa31a7c9beb554f2e992b8ba3f550edd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466fec62dd739ac1202bee83bb48a84c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a466fec62dd739ac1202bee83bb48a84c">aggregate_sample</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;in_sample, std::vector&lt; double &gt; &amp;out_sample)=0</td></tr>
<tr class="memdesc:a466fec62dd739ac1202bee83bb48a84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregate samples from children for the next level up the tree.  <a href="#a466fec62dd739ac1202bee83bb48a84c">More...</a><br /></td></tr>
<tr class="separator:a466fec62dd739ac1202bee83bb48a84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba9bc5764872dd01f8b02759f7f2563"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a0ba9bc5764872dd01f8b02759f7f2563">do_send_sample</a> (void) const =0</td></tr>
<tr class="separator:a0ba9bc5764872dd01f8b02759f7f2563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d973b78871fb7064aec3071958fdd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a4a4d973b78871fb7064aec3071958fdd">adjust_platform</a> (const std::vector&lt; double &gt; &amp;in_policy)=0</td></tr>
<tr class="memdesc:a4a4d973b78871fb7064aec3071958fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the platform settings based the policy from above.  <a href="#a4a4d973b78871fb7064aec3071958fdd">More...</a><br /></td></tr>
<tr class="separator:a4a4d973b78871fb7064aec3071958fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb97f2b7119ab9b38af3ccc18f935324"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#afb97f2b7119ab9b38af3ccc18f935324">do_write_batch</a> (void) const =0</td></tr>
<tr class="memdesc:afb97f2b7119ab9b38af3ccc18f935324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by the Controller to decide whether to call write_batch() to update platform controls.  <a href="#afb97f2b7119ab9b38af3ccc18f935324">More...</a><br /></td></tr>
<tr class="separator:afb97f2b7119ab9b38af3ccc18f935324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223cbd5f3cd63829387a0b9a67166b19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a223cbd5f3cd63829387a0b9a67166b19">sample_platform</a> (std::vector&lt; double &gt; &amp;out_sample)=0</td></tr>
<tr class="memdesc:a223cbd5f3cd63829387a0b9a67166b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read signals from the platform and interpret/aggregate these signals to create a sample which can be sent up the tree.  <a href="#a223cbd5f3cd63829387a0b9a67166b19">More...</a><br /></td></tr>
<tr class="separator:a223cbd5f3cd63829387a0b9a67166b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2c88ac43e7ec80e92e541ddf093ecc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a0d2c88ac43e7ec80e92e541ddf093ecc">wait</a> (void)=0</td></tr>
<tr class="memdesc:a0d2c88ac43e7ec80e92e541ddf093ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by Controller to wait for sample period to elapse. This controls the cadence of the Controller main loop.  <a href="#a0d2c88ac43e7ec80e92e541ddf093ecc">More...</a><br /></td></tr>
<tr class="separator:a0d2c88ac43e7ec80e92e541ddf093ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a830e95ed99627519e4f800d4d45bc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ab1a830e95ed99627519e4f800d4d45bc">report_header</a> (void) const =0</td></tr>
<tr class="memdesc:ab1a830e95ed99627519e4f800d4d45bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields that will be added to the report header when this agent is used.  <a href="#ab1a830e95ed99627519e4f800d4d45bc">More...</a><br /></td></tr>
<tr class="separator:ab1a830e95ed99627519e4f800d4d45bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d89f3b7147ead870b3397ea9512a436"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a8d89f3b7147ead870b3397ea9512a436">report_host</a> (void) const =0</td></tr>
<tr class="memdesc:a8d89f3b7147ead870b3397ea9512a436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields for the host section of the report.  <a href="#a8d89f3b7147ead870b3397ea9512a436">More...</a><br /></td></tr>
<tr class="separator:a8d89f3b7147ead870b3397ea9512a436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cedd11bbf8fb256f25da5e83175d18"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; uint64_t, std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a80cedd11bbf8fb256f25da5e83175d18">report_region</a> (void) const =0</td></tr>
<tr class="memdesc:a80cedd11bbf8fb256f25da5e83175d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom fields for each region in the report.  <a href="#a80cedd11bbf8fb256f25da5e83175d18">More...</a><br /></td></tr>
<tr class="separator:a80cedd11bbf8fb256f25da5e83175d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854cbf10df12e4e53b98a658779d6d53"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a854cbf10df12e4e53b98a658779d6d53">trace_names</a> (void) const =0</td></tr>
<tr class="memdesc:a854cbf10df12e4e53b98a658779d6d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column headers to be added to the trace.  <a href="#a854cbf10df12e4e53b98a658779d6d53">More...</a><br /></td></tr>
<tr class="separator:a854cbf10df12e4e53b98a658779d6d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f233258ac5beba1f7159855428458e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ab0f233258ac5beba1f7159855428458e">trace_values</a> (std::vector&lt; double &gt; &amp;values)=0</td></tr>
<tr class="memdesc:ab0f233258ac5beba1f7159855428458e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by Controller to get latest values to be added to the trace.  <a href="#ab0f233258ac5beba1f7159855428458e">More...</a><br /></td></tr>
<tr class="separator:ab0f233258ac5beba1f7159855428458e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac1b65c000be84bceb2f03123be1bdd8d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ac1b65c000be84bceb2f03123be1bdd8d">num_policy</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:ac1b65c000be84bceb2f03123be1bdd8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the number of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#ac1b65c000be84bceb2f03123be1bdd8d">More...</a><br /></td></tr>
<tr class="separator:ac1b65c000be84bceb2f03123be1bdd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad098ec5298422454848fbc3b843a5a41"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ad098ec5298422454848fbc3b843a5a41">num_sample</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:ad098ec5298422454848fbc3b843a5a41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the number of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#ad098ec5298422454848fbc3b843a5a41">More...</a><br /></td></tr>
<tr class="separator:ad098ec5298422454848fbc3b843a5a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e819dff06b595d740c15092d8e190e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#aa8e819dff06b595d740c15092d8e190e">policy_names</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:aa8e819dff06b595d740c15092d8e190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the names of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#aa8e819dff06b595d740c15092d8e190e">More...</a><br /></td></tr>
<tr class="separator:aa8e819dff06b595d740c15092d8e190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fb21bffad7066b396bbec12697ee6e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a08fb21bffad7066b396bbec12697ee6e">sample_names</a> (const std::map&lt; std::string, std::string &gt; &amp;dictionary)</td></tr>
<tr class="memdesc:a08fb21bffad7066b396bbec12697ee6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to look up the names of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest.  <a href="#a08fb21bffad7066b396bbec12697ee6e">More...</a><br /></td></tr>
<tr class="separator:a08fb21bffad7066b396bbec12697ee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4978ed0ac1acee5374b70cc0acb66e6"><td class="memItemLeft" align="right" valign="top">static std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#ad4978ed0ac1acee5374b70cc0acb66e6">make_dictionary</a> (const std::vector&lt; std::string &gt; &amp;<a class="el" href="classgeopm_1_1_agent.html#aa8e819dff06b595d740c15092d8e190e">policy_names</a>, const std::vector&lt; std::string &gt; &amp;<a class="el" href="classgeopm_1_1_agent.html#a08fb21bffad7066b396bbec12697ee6e">sample_names</a>)</td></tr>
<tr class="memdesc:ad4978ed0ac1acee5374b70cc0acb66e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to create a correctly-formatted dictionary for an <a class="el" href="classgeopm_1_1_agent.html">Agent</a> at the time the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is registered with the factory. Concrete <a class="el" href="classgeopm_1_1_agent.html">Agent</a> classes may provide <a class="el" href="classgeopm_1_1_agent.html#aa8e819dff06b595d740c15092d8e190e" title="Used to look up the names of values in the policy vector sent down the tree for a specific Agent...">policy_names()</a> and <a class="el" href="classgeopm_1_1_agent.html#a08fb21bffad7066b396bbec12697ee6e" title="Used to look up the names of values in the sample vector sent up the tree for a specific Agent...">sample_names()</a> methods to provide the vectors to be passed to this method.  <a href="#ad4978ed0ac1acee5374b70cc0acb66e6">More...</a><br /></td></tr>
<tr class="separator:ad4978ed0ac1acee5374b70cc0acb66e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb920ac60efd06f6a063f979a6e711b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgeopm_1_1_agent.html#a8eb920ac60efd06f6a063f979a6e711b">aggregate_sample</a> (const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;in_sample, const std::vector&lt; std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; &gt; &amp;agg_func, std::vector&lt; double &gt; &amp;out_sample)</td></tr>
<tr class="memdesc:a8eb920ac60efd06f6a063f979a6e711b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generically aggregate a vector of samples given a vector of aggregation functions. This helper method applies a different aggregation function to each sample element while aggregating across child samples.  <a href="#a8eb920ac60efd06f6a063f979a6e711b">More...</a><br /></td></tr>
<tr class="separator:a8eb920ac60efd06f6a063f979a6e711b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a63f44ae327dda74fa4b9642c580aece2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f44ae327dda74fa4b9642c580aece2">&#9670;&nbsp;</a></span>Agent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">geopm::Agent::Agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae25bcbffb10acf177ac9294f24a6e211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25bcbffb10acf177ac9294f24a6e211">&#9670;&nbsp;</a></span>~Agent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual geopm::Agent::~Agent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4a4d973b78871fb7064aec3071958fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4d973b78871fb7064aec3071958fdd">&#9670;&nbsp;</a></span>adjust_platform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::adjust_platform </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_policy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the platform settings based the policy from above. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">policy</td><td>Settings for each control in the policy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a466fec62dd739ac1202bee83bb48a84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466fec62dd739ac1202bee83bb48a84c">&#9670;&nbsp;</a></span>aggregate_sample() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::aggregate_sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aggregate samples from children for the next level up the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_sample</td><td>Vector of sample vectors, one from each child. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_sample</td><td>Aggregated sample values to be sent up to the parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8eb920ac60efd06f6a063f979a6e711b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb920ac60efd06f6a063f979a6e711b">&#9670;&nbsp;</a></span>aggregate_sample() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void geopm::Agent::aggregate_sample </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::function&lt; double(const std::vector&lt; double &gt; &amp;)&gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>agg_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generically aggregate a vector of samples given a vector of aggregation functions. This helper method applies a different aggregation function to each sample element while aggregating across child samples. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_sample</td><td>Vector over children of the sample vector received from each child. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">agg_func</td><td>A vector over agent samples of the aggregation function that is applied. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_sample</td><td>Sample vector resulting from the applying the aggregation across child samples. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa31a7c9beb554f2e992b8ba3f550edd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31a7c9beb554f2e992b8ba3f550edd0">&#9670;&nbsp;</a></span>do_send_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::Agent::do_send_policy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by Controller to determine if new policy values should be sent down the tree to the <a class="el" href="classgeopm_1_1_agent.html">Agent</a>'s children. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the policy has been updated since last call. </dd></dl>

</div>
</div>
<a id="a0ba9bc5764872dd01f8b02759f7f2563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba9bc5764872dd01f8b02759f7f2563">&#9670;&nbsp;</a></span>do_send_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::Agent::do_send_sample </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if new samples were read since last call. </dd></dl>

</div>
</div>
<a id="afb97f2b7119ab9b38af3ccc18f935324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb97f2b7119ab9b38af3ccc18f935324">&#9670;&nbsp;</a></span>do_write_batch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool geopm::Agent::do_write_batch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by the Controller to decide whether to call write_batch() to update platform controls. </p>
<dl class="section return"><dt>Returns</dt><dd>True if platform was adjusted, false otherwise. </dd></dl>

</div>
</div>
<a id="a2c94fff3ed8f580526e51aeb25cf4758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c94fff3ed8f580526e51aeb25cf4758">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>fan_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_level_root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the level where this <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is active and push signals/controls for that level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>Level of the tree where this agent is active. Note that only agents at level zero execute <a class="el" href="classgeopm_1_1_agent.html#a223cbd5f3cd63829387a0b9a67166b19" title="Read signals from the platform and interpret/aggregate these signals to create a sample which can be ...">sample_platform()</a> and <a class="el" href="classgeopm_1_1_agent.html#a4a4d973b78871fb7064aec3071958fdd" title="Adjust the platform settings based the policy from above. ">adjust_platform()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fan_in</td><td>Vector over level giving the the number of Agents that report to each root <a class="el" href="classgeopm_1_1_agent.html">Agent</a> operating at the level. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">is_level_root</td><td>True if the agent plays the role of root of the level. Only root agents for a level execute ascend() and descend(). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4978ed0ac1acee5374b70cc0acb66e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4978ed0ac1acee5374b70cc0acb66e6">&#9670;&nbsp;</a></span>make_dictionary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::map&lt;std::string, std::string&gt; geopm::Agent::make_dictionary </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>policy_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to create a correctly-formatted dictionary for an <a class="el" href="classgeopm_1_1_agent.html">Agent</a> at the time the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> is registered with the factory. Concrete <a class="el" href="classgeopm_1_1_agent.html">Agent</a> classes may provide <a class="el" href="classgeopm_1_1_agent.html#aa8e819dff06b595d740c15092d8e190e" title="Used to look up the names of values in the policy vector sent down the tree for a specific Agent...">policy_names()</a> and <a class="el" href="classgeopm_1_1_agent.html#a08fb21bffad7066b396bbec12697ee6e" title="Used to look up the names of values in the sample vector sent up the tree for a specific Agent...">sample_names()</a> methods to provide the vectors to be passed to this method. </p>

</div>
</div>
<a id="ac1b65c000be84bceb2f03123be1bdd8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b65c000be84bceb2f03123be1bdd8d">&#9670;&nbsp;</a></span>num_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int geopm::Agent::num_policy </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the number of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>

</div>
</div>
<a id="ad098ec5298422454848fbc3b843a5a41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad098ec5298422454848fbc3b843a5a41">&#9670;&nbsp;</a></span>num_sample()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int geopm::Agent::num_sample </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the number of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>

</div>
</div>
<a id="aa8e819dff06b595d740c15092d8e190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e819dff06b595d740c15092d8e190e">&#9670;&nbsp;</a></span>policy_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; geopm::Agent::policy_names </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the names of values in the policy vector sent down the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>

</div>
</div>
<a id="ab1a830e95ed99627519e4f800d4d45bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a830e95ed99627519e4f800d4d45bc">&#9670;&nbsp;</a></span>report_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; geopm::Agent::report_header </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields that will be added to the report header when this agent is used. </p>

</div>
</div>
<a id="a8d89f3b7147ead870b3397ea9512a436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d89f3b7147ead870b3397ea9512a436">&#9670;&nbsp;</a></span>report_host()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; geopm::Agent::report_host </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields for the host section of the report. </p>

</div>
</div>
<a id="a80cedd11bbf8fb256f25da5e83175d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cedd11bbf8fb256f25da5e83175d18">&#9670;&nbsp;</a></span>report_region()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;uint64_t, std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; &gt; geopm::Agent::report_region </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Custom fields for each region in the report. </p>

</div>
</div>
<a id="a08fb21bffad7066b396bbec12697ee6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fb21bffad7066b396bbec12697ee6e">&#9670;&nbsp;</a></span>sample_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; geopm::Agent::sample_names </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dictionary</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to look up the names of values in the sample vector sent up the tree for a specific <a class="el" href="classgeopm_1_1_agent.html">Agent</a>. This should be called with the dictionary returned by <a class="el" href="namespacegeopm.html#ad1b8a10a65586561a73d688c481989f9">agent_factory()</a>.dictionary(agent_name) for the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> of interest. </p>

</div>
</div>
<a id="a223cbd5f3cd63829387a0b9a67166b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223cbd5f3cd63829387a0b9a67166b19">&#9670;&nbsp;</a></span>sample_platform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::sample_platform </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_sample</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read signals from the platform and interpret/aggregate these signals to create a sample which can be sent up the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sample</td><td>Vector of agent specific sample values to be sent up the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33501debc601b7a69bee243c9a3a2351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33501debc601b7a69bee243c9a3a2351">&#9670;&nbsp;</a></span>split_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::split_policy </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by Controller to split policy for children at next level down the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_policy</td><td>Policy values from the parent. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_policy</td><td>Vector of policies to be sent to each child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854cbf10df12e4e53b98a658779d6d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854cbf10df12e4e53b98a658779d6d53">&#9670;&nbsp;</a></span>trace_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; geopm::Agent::trace_names </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Column headers to be added to the trace. </p>

</div>
</div>
<a id="ab0f233258ac5beba1f7159855428458e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f233258ac5beba1f7159855428458e">&#9670;&nbsp;</a></span>trace_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::trace_values </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by Controller to get latest values to be added to the trace. </p>

</div>
</div>
<a id="a76f4eb74c2f1c50b9c85fc988de8c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f4eb74c2f1c50b9c85fc988de8c4c0">&#9670;&nbsp;</a></span>validate_policy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::validate_policy </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>policy</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by Controller to validate incoming policy values and configure defaults requested in incoming policy. Policy sender can request default value with 'NaN' at the desired offset in the policy vector. Returned policy should not contain 'NaN's and be consumeable by descend and adjust_platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">policy</td><td>Policy replace NaN's with defaults. If a value of policy is not NaN but the value is not supported by the <a class="el" href="classgeopm_1_1_agent.html">Agent</a> the method will throw a <a class="el" href="classgeopm_1_1_exception.html" title="Class for all GEOPM-specific exceptions. ">geopm::Exception</a> with error code GEOPM_ERROR_INVALID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d2c88ac43e7ec80e92e541ddf093ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2c88ac43e7ec80e92e541ddf093ecc">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void geopm::Agent::wait </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called by Controller to wait for sample period to elapse. This controls the cadence of the Controller main loop. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="_agent_8hpp_source.html">Agent.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
