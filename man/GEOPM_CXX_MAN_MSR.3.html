<!DOCTYPE html>
<html>
<head>
  <meta http-equiv='content-type' value='text/html;charset=utf8'>
  <meta name='generator' value='Ronn/v0.7.3 (http://github.com/rtomayko/ronn/tree/0.7.3)'>
  <title>geopm::MSR(3) - model-specific register</title>
  <style type='text/css' media='all'>
  /* style: man */
  body#manpage {margin:0}
  .mp {max-width:100ex;padding:0 9ex 1ex 4ex}
  .mp p,.mp pre,.mp ul,.mp ol,.mp dl {margin:0 0 20px 0}
  .mp h2 {margin:10px 0 0 0}
  .mp > p,.mp > pre,.mp > ul,.mp > ol,.mp > dl {margin-left:8ex}
  .mp h3 {margin:0 0 0 4ex}
  .mp dt {margin:0;clear:left}
  .mp dt.flush {float:left;width:8ex}
  .mp dd {margin:0 0 0 9ex}
  .mp h1,.mp h2,.mp h3,.mp h4 {clear:left}
  .mp pre {margin-bottom:20px}
  .mp pre+h2,.mp pre+h3 {margin-top:22px}
  .mp h2+pre,.mp h3+pre {margin-top:5px}
  .mp img {display:block;margin:auto}
  .mp h1.man-title {display:none}
  .mp,.mp code,.mp pre,.mp tt,.mp kbd,.mp samp,.mp h3,.mp h4 {font-family:monospace;font-size:14px;line-height:1.42857142857143}
  .mp h2 {font-size:16px;line-height:1.25}
  .mp h1 {font-size:20px;line-height:2}
  .mp {text-align:justify;background:#fff}
  .mp,.mp code,.mp pre,.mp pre code,.mp tt,.mp kbd,.mp samp {color:#131211}
  .mp h1,.mp h2,.mp h3,.mp h4 {color:#030201}
  .mp u {text-decoration:underline}
  .mp code,.mp strong,.mp b {font-weight:bold;color:#131211}
  .mp em,.mp var {font-style:italic;color:#232221;text-decoration:none}
  .mp a,.mp a:link,.mp a:hover,.mp a code,.mp a pre,.mp a tt,.mp a kbd,.mp a samp {color:#0000ff}
  .mp b.man-ref {font-weight:normal;color:#434241}
  .mp pre {padding:0 4ex}
  .mp pre code {font-weight:normal;color:#434241}
  .mp h2+pre,h3+pre {padding-left:0}
  ol.man-decor,ol.man-decor li {margin:3px 0 10px 0;padding:0;float:left;width:33%;list-style-type:none;text-transform:uppercase;color:#999;letter-spacing:1px}
  ol.man-decor {width:100%}
  ol.man-decor li.tl {text-align:left}
  ol.man-decor li.tc {text-align:center;letter-spacing:4px}
  ol.man-decor li.tr {text-align:right;float:right}
  </style>
</head>
<!--
  The following styles are deprecated and will be removed at some point:
  div#man, div#man ol.man, div#man ol.head, div#man ol.man.

  The .man-page, .man-decor, .man-head, .man-foot, .man-title, and
  .man-navigation should be used instead.
-->
<body id='manpage'>
  <div class='mp' id='man'>

  <div class='man-navigation' style='display:none'>
    <a href="#NAME">NAME</a>
    <a href="#SYNOPSIS">SYNOPSIS</a>
    <a href="#DESCRIPTION">DESCRIPTION</a>
    <a href="#MSR-BITFIELD-ENCODING">MSR BITFIELD ENCODING</a>
    <a href="#MSR-CLASS-METHODS">MSR CLASS METHODS</a>
    <a href="#MSRSIGNAL-CLASS-METHODS">MSRSIGNAL CLASS METHODS</a>
    <a href="#MSRCONTROL-CLASS-METHODS">MSRCONTROL CLASS METHODS</a>
    <a href="#COPYRIGHT">COPYRIGHT</a>
    <a href="#SEE-ALSO">SEE ALSO</a>
  </div>

  <ol class='man-decor man-head man head'>
    <li class='tl'>geopm::MSR(3)</li>
    <li class='tc'></li>
    <li class='tr'>geopm::MSR(3)</li>
  </ol>

  <h2 id="NAME">NAME</h2>
<p class="man-name">
  <code>geopm::MSR</code> - <span class="man-whatis">model-specific register</span>
</p>

<h2 id="SYNOPSIS">SYNOPSIS</h2>

<p><strong>#include <a href="https://github.com/geopm/geopm/blob/dev/src/MSR.hpp">&lt;geopm/MSR.hpp></a></strong><br />
<strong>#include <a href="https://github.com/geopm/geopm/blob/dev/src/MSRSignal.hpp">&lt;geopm/MSRSignal.hpp></a></strong><br />
<strong>#include <a href="https://github.com/geopm/geopm/blob/dev/src/MSRControl.hpp">&lt;geopm/MSRControl.hpp></a></strong></p>

<p><code>Link with -lgeopm (MPI) or -lgeopmpolicy (non-MPI)</code></p>

<ul>
<li><p><code>struct m_encode_s {</code>:
<code>int</code> <em>begin_bit</em>; <br />
<code>int</code> <em>end_bit</em>; <br />
<code>int</code> <em>domain</em>; <br />
<code>int</code> <em>function</em>; <br />
<code>int</code> <em>units</em>; <br />
<code>double</code> <em>scalar</em>; <code>};</code></p></li>
<li><p><code>enum m_function_e;</code></p></li>
<li><p><code>enum m_units_e;</code></p></li>
<li><p><code>std::string MSR::name(</code>:
<code>void) const;</code></p></li>
<li><p><code>uint64_t MSR::offset(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSR::num_signal(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSR::num_control(</code>:
<code>void) const;</code></p></li>
<li><p><code>std::string MSR::signal_name(</code>:
<code>int</code><em>signal_idx</em><code>) const;</code></p></li>
<li><p><code>std::string MSR::control_name(</code>:
<code>int</code><em>control_idx</em><code>) const;</code></p></li>
<li><p><code>int MSR::signal_index(</code>:
<code>const std::string &amp;</code><em>name</em><code>) const;</code></p></li>
<li><p><code>int MSR::control_index(</code>:
<code>const std::string &amp;</code><em>name</em><code>) const;</code></p></li>
<li><p><code>double MSR::signal(</code>:
<code>int</code><em>signal_idx</em><code>,</code><br />
<code>uint64_t</code><em>field</em><code>,</code><br />
<code>uint64_t &amp;</code><em>last_field</em><code>,</code><br />
<code>uint64_t &amp;</code><em>num_overflow</em><code>) const;</code></p></li>
<li><p><code>void MSR::control(</code>:
<code>int</code><em>control_idx</em><code>,</code><br />
<code>double</code><em>value</em><code>,</code><br />
<code>uint64_t &amp;</code><em>field</em><code>,</code><br />
<code>uint64_t &amp;</code><em>mask</em><code>) const;</code></p></li>
<li><p><code>uint64_t MSR::mask(</code>:
<code>int</code><em>control_idx</em><code>) const;</code></p></li>
<li><p><code>int MSR::domain_type(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSR::decode_function(</code>:
<code>int</code><em>signal_idx</em><code>) const;</code></p></li>
<li><p><code>std::string MSRSignal::name(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSRSignal::domain_type(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSRSignal::cpu_idx(</code>:
<code>void) const;</code></p></li>
<li><p><code>double MSRSignal::sample(</code>:
<code>void);</code></p></li>
<li><p><code>uint64_t MSRSignal::offset(</code>:
<code>void) const;</code></p></li>
<li><p><code>void MSRSignal::map_field(</code>:
<code>const uint64_t *</code><em>field</em><code>);</code></p></li>
<li><p><code>std::string MSRControl::name(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSRControl::domain_type(</code>:
<code>void) const;</code></p></li>
<li><p><code>int MSRControl::cpu_idx(</code>:
<code>void) const;</code></p></li>
<li><p><code>void MSRControl::adjust(</code>:
<code>double</code><em>setting</em><code>);</code></p></li>
<li><p><code>uint64_t MSRControl::offset(</code>:
<code>void) const;</code></p></li>
<li><p><code>uint64_t MSRControl::mask(</code>:
<code>void) const;</code></p></li>
<li><p><code>void MSRControl::map_field(</code>:
<code>uint64_t *</code><em>field</em><code>,</code><br />
<code>uint64_t *</code><em>mask</em><code>);</code></p></li>
</ul>


<h2 id="DESCRIPTION">DESCRIPTION</h2>

<p>The <code>MSR</code> class encapsulates details of Model Specific Registers
(MSRs) on Intel architectures.  This page provides information that
may be useful for developers wishing to extend or modify the set of
MSRs available or add new supported platforms; general users of
<strong><a class="man-ref" href="GEOPM_CXX_MAN_PlatformIO.3.html">geopm::PlatformIO<span class="s">(3)</span></a></strong> should not need to be concerned with these
implementation details.  A complete reference covering the format and
usage of MSRs can be found in The Intel Software Developer's Manual at
<a href="https://software.intel.com/en-us/articles/intel-sdm" data-bare-link="true">https://software.intel.com/en-us/articles/intel-sdm</a>.  The
<code>MSRSignal</code> and <code>MSRControl</code> classes are used to represent individual
bitfields of an MSR for reading or writing respectively.  Note that in
most cases, all fields of an MSR will be read only (signals) or
writeable (controls).  In some cases, fields which are controls have
also been exposed as signals for inspection and debugging purposes.
Also note that the set of MSRs made available through GEOPM is a
subset of all MSRs on supported systems.  The MSRs supported for a
given system can be seen using <strong><a class="man-ref" href="geopmread.1.html">geopmread<span class="s">(1)</span></a></strong> for signals,
<strong><a class="man-ref" href="geopmwrite.1.html">geopmwrite<span class="s">(1)</span></a></strong> for controls, or in the source code for individual
platforms in src/msr_*.cpp.</p>

<p>MSRs are defined for hardware domains, described in
<strong><a class="man-ref" href="GEOPM_CXX_MAN_PlatformTopo.3.html">geopm::PlatformTopo<span class="s">(3)</span></a></strong>.  Although the underlying file descriptor
interface for reading and writing MSRs uses Linux logical CPUs, in
many cases the MSR is only applicable at a wider granularity.  This
detail is hidden when using <strong><a class="man-ref" href="GEOPM_CXX_MAN_MSRIOGroup.3.html">geopm::MSRIOGroup<span class="s">(3)</span></a></strong> through
<strong><a class="man-ref" href="GEOPM_CXX_MAN_PlatformIO.3.html">geopm::PlatformIO<span class="s">(3)</span></a></strong> to access MSR-based signals and controls.</p>

<h2 id="MSR-BITFIELD-ENCODING">MSR BITFIELD ENCODING</h2>

<p>The <code>m_encode_s</code> structure describes a bitfield within an MSR. The fields are:</p>

<pre><code>* _begin_bit_:
First bit of the field, (inclusive)

* _end_bit_:
Last bit of the field (exclusive)

* _domain_:
The hardware domain over which the MSR is applicable.  See
**geopm::IPlatformTopo(3)** for descriptions of the domains.

* _function_:
Encoding function that converts the bit field into an integer to
be scaled (see m_function_e below)

* _units_:
SI unit of the signal or control (see m_units_e below)

* _scalar_:
Scale factor used to convert integer output of function to SI
units.
</code></pre>

<p>The <code>m_function_e</code> enum specifies the encoding/decoding function used
to convert the bitfield into SI units. The available functions are:</p>

<pre><code>* _M_FUNCTION_SCALE_:
Multiply by the scalar value only.  The scalar is also applied by
all other functions.

* _M_FUNCTION_LOG_HALF_:
A number encoded using the formula 2.0 ^ -X

* _M_FUNCTION_7_BIT_FLOAT_:
A floating-point number encoded in 7 bits using the formula `2 ^ Y
* (1.0 + Z / 4.0) : Y in [0:5), Z in [5:7)`

* _M_FUNCTION_OVERFLOW_:
Used for counters that may overflow.
</code></pre>

<p>The <code>m_units_e</code> enum specifies the SI unit for a signal or control.
The available units are:</p>

<pre><code>* _M_UNITS_NONE_:
Used for counters and other quantities with no units.

* _M_UNITS_SECONDS_:
Used for time in seconds.

* _M_UNITS_HERTZ_:
Used for frequency in hertz.

* _M_UNITS_WATTS_:
Used for power in watts.

* M_UNITS_JOULES_:
Used for energy in joules.

* _M_UNITS_CELSIUS_:
Used for temperature in degrees Celsius.
</code></pre>

<h2 id="MSR-CLASS-METHODS">MSR CLASS METHODS</h2>

<dl>
<dt class="flush"><code>name</code>()</dt><dd><p>Returns the name of the MSR provided in the SDM.</p></dd>
<dt><code>offset</code>()</dt><dd><p>Returns the 64-bit byte offset to register address for the MSR.</p></dd>
<dt><code>num_signal</code>()</dt><dd><p>Returns the number of distinct signals encoded as bit fields in
the MSR.</p></dd>
<dt><code>num_control</code>()</dt><dd><p>Returns the number of distinct controls encoded as bit fields in the MSR.</p></dd>
<dt><code>signal_name</code>()</dt><dd><p>Returns the name of the signal with field index <em>signal_idx</em>.  The index
ranges from 0 to num_signal() - 1.</p></dd>
<dt><code>control_name</code>()</dt><dd><p>Returns the name of the control with field index <em>signal_idx</em>.  The index
ranges from 0 to num_control() - 1.</p></dd>
<dt><code>signal_index</code>()</dt><dd><p>Returns the field index for the signal with the given <em>name</em>.
If the name is not found, -1 is returned.</p></dd>
<dt><code>control_index</code>()</dt><dd><p>Returns the field index for the control with the given <em>name</em>.
If the name is not found, -1 is returned.</p></dd>
<dt><code>signal</code>()</dt><dd><p>Extract and decode into SI units the signal at <em>signal_idx</em> from a
64-bit register value, <em>field</em>.  If the decode function is
M_FUNCTION_OVERFLOW, <em>last_field</em> should contain the previous
value of the register and the value will be updated when the
function returns.  Similarly <em>num_overflow</em> is an in-out parameter
containing the number of times the register overflowed.</p></dd>
<dt><code>control</code>()</dt><dd><p>Set the control bit field at <em>control_idx</em> in an MSR.  The <em>value</em>
in SI units will be encoded.  The write mask is returned through
the parameter <em>mask</em> and the raw bits of the MSR to be written are
returned in <em>field</em>.</p></dd>
<dt class="flush"><code>mask</code>()</dt><dd><p>Returns the write mask given a bit field index <em>control_idx</em>.</p></dd>
<dt><code>domain_type</code>()</dt><dd><p>Returns the type of the domain that the MSR encodes.  All bit
fields of an MSR are the same domain.  See
<strong><a class="man-ref" href="GEOPM_CXX_MAN_PlatformTopo.3.html">geopm::PlatformTopo<span class="s">(3)</span></a></strong> for more information on domains.</p></dd>
<dt><code>decode_function</code>()</dt><dd><p>The function used to decode the MSR value as defined
in the m_function_e enum.</p></dd>
</dl>


<h2 id="MSRSIGNAL-CLASS-METHODS">MSRSIGNAL CLASS METHODS</h2>

<dl>
<dt class="flush"><code>name</code>()</dt><dd><p>Returns the name of the feature being measured.</p></dd>
<dt><code>domain_type</code>()</dt><dd><p>Returns the type of the domain under measurement.  See
<strong><a class="man-ref" href="GEOPM_CXX_MAN_PlatformTopo.3.html">geopm::PlatformTopo<span class="s">(3)</span></a></strong> for more information on domains.</p></dd>
<dt><code>cpu_idx</code>()</dt><dd><p>Returns the index of the logical Linux CPU used by this signal.
For domains that span multiple CPUs, there will be multiple
MSRSignals corresponding to different CPUs that read the same
system value.</p></dd>
<dt><code>sample</code>()</dt><dd><p>Returns the value of the signal in SI units.</p></dd>
<dt><code>offset</code>()</dt><dd><p>Returns the MSR offset for a signal.</p></dd>
<dt><code>map_field</code>()</dt><dd><p>Map 64 bits of memory at location <em>field</em> storing the raw value of
an MSR that will be referenced when calculating the signal.</p></dd>
</dl>


<h2 id="MSRCONTROL-CLASS-METHODS">MSRCONTROL CLASS METHODS</h2>

<dl>
<dt class="flush"><code>name</code>()</dt><dd><p>Returns the name of the feature under control.</p></dd>
<dt><code>domain_type</code>()</dt><dd><p>Returns the type of the domain under control.  See
<strong><a class="man-ref" href="GEOPM_CXX_MAN_PlatformTopo.3.html">geopm::PlatformTopo<span class="s">(3)</span></a></strong> for more information on domains.</p></dd>
<dt><code>cpu_idx</code>()</dt><dd><p>Returns the index of the logical Linux CPU used by this control.
For domains that span multiple CPUs, there will be multiple
MSRControls corresponding to different CPUs that write the same
system value.</p></dd>
<dt><code>adjust</code>()</dt><dd><p>Set the value in SI units for the control to <em>setting</em>.</p></dd>
<dt><code>offset</code>()</dt><dd><p>Returns the MSR offset for a control.</p></dd>
<dt class="flush"><code>mask</code>()</dt><dd><p>Returns the mask for the MSR that is written by the control.</p></dd>
<dt><code>map_field</code>()</dt><dd><p>Map 64 bits of memory at location <em>field</em> storing the raw value of
an MSR that will be referenced when enforcing the control.  The
mask to be applied when writing the control is stored in the
location pointed to by <em>mask</em>.</p></dd>
</dl>


<h2 id="COPYRIGHT">COPYRIGHT</h2>

<p>Copyright (c) 2015, 2016, 2017, 2018, 2019, Intel Corporation. All rights reserved.</p>

<h2 id="SEE-ALSO">SEE ALSO</h2>

<p><strong><a class="man-ref" href="geopm.7.html">geopm<span class="s">(7)</span></a></strong>,
<strong><a class="man-ref" href="GEOPM_CXX_MAN_MSRIO.3.html">geopm::MSRIO<span class="s">(3)</span></a></strong>,
<strong><a class="man-ref" href="GEOPM_CXX_MAN_MSRIOGroup.3.html">geopm::MSRIOGroup<span class="s">(3)</span></a></strong>,
<strong><a class="man-ref" href="geopmread.1.html">geopmread<span class="s">(1)</span></a></strong>,
<strong><a class="man-ref" href="geopmwrite.1.html">geopmwrite<span class="s">(1)</span></a></strong></p>


  <ol class='man-decor man-foot man foot'>
    <li class='tl'>GEOPM 1.0.0+dev198ga6ad1a7</li>
    <li class='tc'>October 2019</li>
    <li class='tr'>geopm::MSR(3)</li>
  </ol>

  </div>
</body>
</html>
